import Draggable from "draggable"

class GamepadOverlay {

  /**
   * PUBLIC FUNCTIONS
   **/
  constructor({domHook}) {
    if (!domHook) {
      throw new Error("no domHook was provided in the constructor of GamepadOverlayProvider")
    }
    this.domHook = domHook;
    this.buttons = {};
    this.axes = {};
    this.sticks = {};
    if(GamepadOverlay.instanceId){
      GamepadOverlay.instanceId++;
    } else {
      GamepadOverlay.instanceId = 0;
    }
    this.id = GamepadOverlay.instanceId;
  };

  getDomHook() {
    return this.domHook;
  }

  toHTML5GamepadAPI(){
    return {
      axes: Object.keys(this.axes).map(axeKey => this.axes[axeKey]),
      buttons: Object.keys(this.buttons).map(buttonKey => ({
            pressed:this.buttons[buttonKey].pressed,
            value: this.buttons[buttonKey].pressed ? 1 : 0
          })
      ),
      connected: true,
      timestamp: Date.now(),
      id: `overlay-${this.id}`
    }
  }

  createNewStick({
                   code,
                   radius = 0,
                   styles = {},
                   stickButtonStyles = {},
                   stickButtonScale = 0.5,
                   snapBackDelay = 0,
                   onMove = () => null,
                   onMoveEnd = () => null
                 }) {

    if (code !== 0 && !code) {
      throw new Error("no code provided in GamepadOverlayProvider.createNewStick")
    }

    const stick = {
      code,
      axes: {
        0: 0,
        1: 0
      },
      ui: document.createElement("div"),
      pressed: false
    };
    stick.ui.style.width = `${radius * 2}px`;
    stick.ui.style.height = `${radius * 2}px`;
    stick.ui.style.borderRadius = "50%";
    const stickButton = document.createElement("button");
    stickButton.style.position = "relative";
    stickButton.style.left = `${(1 - stickButtonScale) * radius}px`;
    stickButton.style.top = `${(1 - stickButtonScale) * radius}px`;
    stickButton.style.borderRadius = "50%";
    stickButton.style.width = `${2 * stickButtonScale * radius}px`;
    stickButton.style.height = `${2 * stickButtonScale * radius}px`;
    stickButton.style.padding = "0px";
    stickButton.style.border = "1px solid grey";
    this.getDomHook().appendChild(stick.ui);
    stick.buttonUi = stickButton;
    stick.ui.appendChild(stickButton);
    new Draggable(stickButton, {
      limit: function (
          x,  // current X coordinate
          y,  // current Y coordinate
          x0, // original X coordinate (where drag was started)
          y0  // original Y coordinate (where drag was started)
      ) {

        const dx = x - x0;
        const dy = y - y0;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const outOfRange = distance > radius;

        if (outOfRange) {
          x = x0 + radius * (x - x0) / distance;
          y = y0 + radius * (y - y0) / distance;
        }

        return {x, y};

      },
      onDrag: () => {
        stick.axes[0] = (Math.round(this._getValueOutOfStyleProp(stickButton.style.left)) - (1 - stickButtonScale) * radius) * 2 / 100;
        stick.axes[1] = (Math.round(this._getValueOutOfStyleProp(stickButton.style.top)) - (1 - stickButtonScale) * radius) * 2 / 100;
        this.axes[`${code}-0`] = stick.axes[0];
        this.axes[`${code}-1`] = stick.axes[1];
        onMove(stick);
      },
      onDragEnd: () => {
        setTimeout(() => {
          stickButton.style.left = `${(1 - stickButtonScale) * radius}px`;
          stickButton.style.top = `${(1 - stickButtonScale) * radius}px`;
          stick.axes[0] = 0;
          stick.axes[1] = 0;
          this.axes[`${code}-0`] = stick.axes[0];
          this.axes[`${code}-1`] = stick.axes[1];
          onMoveEnd(stick);
        }, snapBackDelay)
      }
    });

    this.sticks[code] = stick;
    this.axes[`${code}-0`] = stick.axes[0];
    this.axes[`${code}-1`] = stick.axes[1];
    this._mergeStylesToObject(stick.ui, styles);
    this._mergeStylesToObject(stickButton, stickButtonStyles);
  }

  createNewButton({
                    code,
                    width = 0,
                    height = 0,
                    text = "",
                    styles = {},
                    onPress = () => null,
                    onRelease = () => null
  }) {

    if (code !== 0 && !code) {
      throw new Error("no code provided in GamepadOverlayProvider.createNewButton")
    }

    const button = {
      code,
      ui: document.createElement("button"),
      pressed: false
    };
    button.ui.innerText = text;
    button.ui.style.width = `${width}px`;
    button.ui.style.height = `${height}px`;
    button.ui.style.outline = "none";

    const buttonPressed = () => {
      button.pressed = true;
      onPress(button);
    };

    const buttonReleased = () => {
      button.pressed = false;
      onRelease(button);
    };

    button.ui.addEventListener("mousedown", buttonPressed);
    button.ui.addEventListener("touchstart", buttonPressed);
    button.ui.addEventListener("touchend", buttonReleased);
    button.ui.addEventListener("mouseup", buttonReleased);
    button.ui.addEventListener("mouseleave", buttonReleased);

    this._mergeStylesToObject(button.ui, styles);
    this.getDomHook().appendChild(button.ui);
    this.buttons[code] = button;
  }

  /**
   * PRIVATE FUNCTIONS
   **/

  _getValueOutOfStyleProp(styleProp) {
    return styleProp.substr(0, styleProp.indexOf("px"))
  }

  _mergeStylesToObject(obj, styles) {
    Object.keys(styles).forEach(styleKey => {
      if (obj.style.hasOwnProperty(styleKey) && styles.hasOwnProperty(styleKey)) {
        obj.style[styleKey] = styles[styleKey]
      }
    });
  }
}

export default GamepadOverlay;
